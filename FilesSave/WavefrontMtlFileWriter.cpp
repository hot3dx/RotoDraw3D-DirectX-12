//--------------------------------------------------------------------------------------
// File: Hot3dxRotoDrawMain.h
//
// Copyright (c) 2020 Jeff Kubitz - hot3dx. All rights reserved.
// And by CoPilot AI - OpenAI
// No warranty is expressed or implied use at own risk
//
//--------------------------------------------------------------------------------------#pragma once

#include "pch.h"
#include "WavefrontMtlFileWriter.h"
#include "Content/Hot3dxRotoDrawSceneRender.h"
#include "Content/Hot3dxRotoDrawVariables.h"
#include <iostream>
#include <fstream>
#include <string>
#include <codecvt>
#include <locale>
#include <sstream>

using namespace std;
using namespace Hot3dxRotoDraw;

    Hot3dxRotoDraw::WavefrontMtlFileWriter::WavefrontMtlFileWriter(const std::string& filename, unsigned int materialCount)
        : m_filename(filename), m_materialCount(materialCount)
    {
    }

    Hot3dxRotoDraw::WavefrontMtlFileWriter::~WavefrontMtlFileWriter()
    {
    }

    void Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteMtlFile(std::ofstream& outFile)
    {
        // Write file header or comments
        outFile << "# Wavefront material file\n";
        outFile << "# Generated by WavefrontMtlFileWriter\n\n";

        // Your header/data writing logic goes here
        // This is a placeholder until connected to actual material data
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteHeader(unsigned int index, const std::string& objectName)
    {
        return "newmtl " + objectName + "_" + std::to_string(index) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteMaterialListHeader(
        const std::string& effectName,
        unsigned int illumType,
        const std::string& node,
        const std::string& colorType,
        const std::string& textureFilename,
        unsigned int materialIndex,
        MaterialDataVector^ list)
    {
        
        std::ostringstream oss;
        // Loop through each material in the list
        for (unsigned int i = 0; i < list->GetMaterialDataVector().size(); ++i)
        {
            WriteHeader(materialIndex, node);
            const MaterialData& matData = list->GetMaterialDataVector().at(i);

            const char* ch = effectName.c_str();
			wchar_t* wch = nullptr;
			std::mbsrtowcs(wch, &ch, 0, nullptr);
			list->GetMaterialDataVector().at(i).effectName = ref new Platform::String(wch);
            list->GetMaterialDataVector().at(i).m_illumType = illumType;


            ch = textureFilename.c_str();
            wch = nullptr;
            std::mbsrtowcs(wch, &ch, 0, nullptr);
            list->GetMaterialDataVector().at(i).wcfileName = ref new Platform::String(wch);

            ch = colorType.c_str();
            wch = nullptr;
            std::mbsrtowcs(wch, &ch, 0, nullptr);
            list->GetMaterialDataVector().at(i).matName = ref new Platform::String(wch);
            
            oss << WriteHeader(i, ConvertToStdString(matData.matName));
            oss << WriteMaterialNameType(ConvertToStdString(matData.nodeName), ConvertToStdString(matData.effectName));
            oss << WriteIllum(matData.m_illumType);
            oss << WriteKa(matData.kaR, matData.kaG, matData.kaB);
            oss << WriteKd(matData.kdR, matData.kdG, matData.kdB);
            oss << WriteKs(matData.ksR, matData.ksG, matData.ksB);
            oss << WriteNs(matData.ns);
            oss << WriteNi(matData.ni);
            oss << WriteD(matData.d);
            if (!ConvertToStdString(matData.wcfileName).empty()) {
                oss << WriteTextureMap(
                    ConvertToStdString(ref new Platform::String(std::to_wstring(matData.m_mapType).c_str())),
                    ConvertToStdString(matData.wcfileName));
            }
            oss << "\n";
        }
        return oss.str();
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteMaterialListII(const std::string& effectName, unsigned int illumType, const std::string& node, const std::string& colorType, const std::string& textureFilename, unsigned int materialIndex, MaterialDataVector^ list)
    {
        std::ostringstream oss;
        // Loop through the material list and write Ka, Kd, Ks, Ns, etc.
        for (unsigned int i = 0; i < list->GetMaterialDataVector().size(); ++i)
        {
            const char* ch = effectName.c_str();
            wchar_t* wch = nullptr;
            std::mbsrtowcs(wch, &ch, 0, nullptr);
            list->GetMaterialDataVector().at(i).effectName = ref new Platform::String(wch);
            list->GetMaterialDataVector().at(i).m_illumType = illumType;    
            oss << WriteHeader(materialIndex, node);
            oss << WriteIllum(illumType);
            // Just examples — you'd loop material list here and add Ka/Kd/Ks/Ns
            oss << WriteTextureMap(colorType, textureFilename);
            const MaterialData& matData = list->GetMaterialDataVector().at(i);
            oss << WriteKa(matData.kaR, matData.kaG, matData.kaB);
            oss << WriteKd(matData.kdR, matData.kdG, matData.kdB);
            oss << WriteKs(matData.ksR, matData.ksG, matData.ksB);
            oss << WriteNs(matData.ns);
            oss << WriteNi(matData.ni);
            oss << WriteD(matData.d);
        }

        // Write texture map
        oss << WriteTextureMap(colorType, textureFilename);

        return oss.str();
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteMaterialNameType(const std::string& node, const std::string& type)
    {
        return "# Node: " + node + ", Type: " + type + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteIllum(unsigned int n)
    {
        return "illum " + std::to_string(n) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteKa(float r, float g, float b)
    {
        return "Ka " + std::to_string(r) + " " + std::to_string(g) + " " + std::to_string(b) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteKd(float r, float g, float b)
    {
        return "Kd " + std::to_string(r) + " " + std::to_string(g) + " " + std::to_string(b) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteKs(float r, float g, float b)
    {
        return "Ks " + std::to_string(r) + " " + std::to_string(g) + " " + std::to_string(b) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteNs(float value)
    {
        return "Ns " + std::to_string(value) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteNi(float value)
    {
        return "Ni " + std::to_string(value) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteD(float value)
    {
        return "d " + std::to_string(value) + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::WriteTextureMap(const std::string& type, const std::string& filename)
    {
        return "map_" + type + " " + filename + "\n";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::ConvertToStdString(Platform::String^ ps)
    {
        if (ps == nullptr)
        {
            const wchar_t* wstring = L"0";
			std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
            return converter.to_bytes(wstring);
        }
        else if (ps->Length() <= 0)
        {
            const wchar_t* wstring = L"";
            std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
            return converter.to_bytes(wstring);
        }
        else if (ps->Length() > 0)
        {
            std::wstring wstr = ps->Data();
            std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
            return converter.to_bytes(wstr);
        }

        return "";
    }

    std::string Hot3dxRotoDraw::WavefrontMtlFileWriter::BuildMaterialBlock(const MaterialDataVector^ list, const MaterialData& matData, unsigned int index)
    {
        std::ostringstream mtlBlock;  

        mtlBlock << WriteHeader(index, ConvertToStdString(matData.matName));  
        mtlBlock << WriteMaterialNameType(ConvertToStdString(matData.nodeName), ConvertToStdString(matData.effectName));  
        mtlBlock << WriteIllum(matData.m_illumType);
        
        mtlBlock << WriteKa(matData.kaR, matData.kaG, matData.kaB);  
        mtlBlock << WriteKd(matData.kdR, matData.kdG, matData.kdB);  
        mtlBlock << WriteKs(matData.ksR, matData.ksG, matData.ksB);  
        mtlBlock << WriteNs(matData.ns);  
        mtlBlock << WriteNi(matData.ni);  
        mtlBlock << WriteD(matData.d);
     

        if (!ConvertToStdString(matData.wcfileName).empty()) {
            mtlBlock << WriteTextureMap(ConvertToStdString(ref new Platform::String(std::to_wstring(matData.m_mapType).c_str())), ConvertToStdString(matData.wcfileName));
        }
        return mtlBlock.str();  
    }

    // 
   /* call in main writer
   for (size_t i = 0; i < materials.size(); ++i) {
       const auto& mat = materials[i];
       outFile << BuildMaterialBlock(mat, static_cast<unsigned int>(i));
   }
   */

